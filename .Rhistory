fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~noms_en_gb,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", noms_en_gb, "<br>IDH: ", HDI_value,  "<br>Tempo moyen: ", moyenne_tempo,  "<br>Tempo median: ", median_tempo )
) %>%
addCircles(data = as.data.frame(centroid_coords), # Utiliser les centroïdes comme données pour les bulles
lat = ~Y,  # Latitude du centroïde
lng = ~X,  # Longitude du centroïde
radius = ~songs_pays_spotify$moyenne_danceability * 500,
color = "brown",
fillOpacity = 0.7,
popup = ~paste("Pays: ", songs_pays_spotify$noms_en_gb, "<br>Danceability: ", songs_pays_spotify$moyenne_danceability)
)
# Afficher la carte
carte
# Calculer la régression linéaire
modele <- lm(moyenne_danceability  ~ HDI_value, data=songs_pays_spotify)
summary(modele)
# Nuage de points avec la ligne de régression
plot(songs_pays_spotify$HDI_value, songs_pays_spotify$moyenne_danceability,
xlab = "IDH", ylab = "Danceability",
main = "Relation entre l'IDH et la Danceabilité d'une chanson")
abline(modele, col = "red")  # Ajouter la ligne de régression
##################Influence de la géolocalisation sur la popularité#####################
#Selectionner la top chanson mondiale
top_chanson_mondiale <- subset(spotifydb, daily_rank == "1" & country =="" & snapshot_date =="2023-10-18")
#Selectionner la même top chanson mondiale pour voire sa popularité par pays
top_chanson_all <- subset(spotifydb, spotify_id == top_chanson_mondiale$spotify_id & snapshot_date == top_chanson_mondiale$snapshot_date)
#Enlever la top mondiale qui a country vide pour n'avoir que les pays où la chanson est un hit
#Resultat de la jointure entre la table spotify et la table des codes ISO
top_chanson_pays <- top_chanson_all %>% filter( country != "")
# Fusionner ces données avec ceux des codeIso
top_chanson_pays_iso <- merge(top_chanson_pays, isoCodes, by.x ="country", by.y ="alpha2", all = FALSE)
# Fusionner ces données avec les données sur l'IDH des pays
top_chanson_pays_iso_idh <- merge(top_chanson_pays_iso, hdiCountries, by.x = "noms_en_gb", by.y = "Country", all = FALSE)
# Effectuer la jointure entre le shapefile et la table des tops chansons
top_chanson_pays_iso_idh_pays <- merge(pays, top_chanson_pays_iso_idh, by.x = "iso3", by.y = "alpha3", all.x = FALSE)
# Calculer la régression linéaire
modele_top_chanson <- lm(daily_rank  ~ HDI_value, data=top_chanson_pays_iso_idh)
summary(modele_top_chanson)
# Nuage de points avec la ligne de régression
plot(top_chanson_pays_iso_idh$HDI_value, top_chanson_pays_iso_idh$daily_rank,
xlab = "IDH", ylab = "Classement chanson",
main = "Relation entre l'IDH et la popularité d'une chanson")
abline(modele_top_chanson, col = "red")  # Ajouter la ligne de régression
#Afficher ce lien cartographiquement
# Convertir le dataframe en un objet 'sf'
data_sf <- st_as_sf(top_chanson_pays_iso_idh_pays)
# Créer la carte
ggplot() +
geom_sf(data = data_sf, aes(fill = daily_rank), color = "white") + # Dégradé de couleur basé sur la popularité
scale_fill_gradient(low = "lightblue", high = "darkblue", name = "Popularity") + # Choix du dégradé de couleur
labs(title = "Popularité de la chanson par pays", caption = "Source: Votre source de données") + # Titre et légende
theme_minimal() + # Style minimal du graphique
geom_sf_text(aes(label = top_chanson_pays_iso_idh_pays$HDI_value), size = 3, color = "black", check_overlap = TRUE) # Affichage de l'IDH en texte
View(top_chanson_pays_iso_idh_pays)
# Convertir le dataframe en un objet 'sf'
data_sf <- st_as_sf(top_chanson_pays_iso_idh_pays, wkt = "geometry")
# Créer la carte
ggplot() +
geom_sf(data = data_sf, aes(fill = popularity), color = "white") +
scale_fill_gradient(low = "lightblue", high = "darkblue", name = "Popularity") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_sf_text(aes(label = HDI_value), size = 3, color = "black", check_overlap = TRUE)
View(data_sf)
# Créer la carte
ggplot() +
geom_sf(data = data_sf, aes(fill = popularity), color = "white") +
scale_fill_gradient(low = "lightblue", high = "darkblue", name = "Popularity") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_sf_text(aes(label = data_sf$HDI_value), size = 3, color = "black", check_overlap = TRUE)
#Afficher ce lien cartographiquement
write.csv(top_chanson_pays_iso_idh_pays, file = "C:/Users/hasdi/OneDrive/Desktop/Projet Proba Stat/top_chanson_pays_iso_idh_pays.csv", row.names = FALSE)
View(top_chanson_pays_iso_idh_pays)
# Convertir le dataframe en un objet 'sf'
data_sf <- st_as_sf(top_chanson_pays_iso_idh_pays, wkt = "geometry")
# Créer la carte
ggplot() +
geom_sf(data = data_sf, aes(fill = popularity)) +
scale_fill_gradient(low = "lightblue", high = "darkblue", name = "Popularity") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_sf_text(data = data_sf, aes(label = HDI_value), size = 3, color = "black", check_overlap = TRUE)
# Créer la carte
ggplot() +
geom_sf(data = data_sf, aes(fill = daily_rank)) +
scale_fill_gradient(low = "lightblue", high = "darkblue", name = "Popularity") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_sf_text(data = data_sf, aes(label = HDI_value), size = 3, color = "black", check_overlap = TRUE)
# Normaliser le classement pour l'utiliser comme taille des points (inverse du classement)
data_sf$normalized_rank <- 1 / data_sf$daily_rank
# Créer la carte en associant l'IDH et le classement à la couleur et à la taille des points
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Relation entre l'IDH et le classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_sf(data = data_sf, aes(size = normalized_rank), color = "black", alpha = 0.5) +
guides(size = FALSE)  # Supprimer la légende de la taille des points
# Normaliser les tailles des bulles entre 1 et 10 (ou une autre échelle) pour un affichage adéquat
data_sf$size <- rescale(data_sf$normalized_rank, to = c(1, 10))
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_sf$normalized_rank <- 1 / data_sf$daily_rank
# Normaliser les valeurs pour les utiliser comme taille des bulles
data_sf$size <- scale(data_sf$normalized_rank, range = c(1, 20))  # Vous pouvez ajuster la plage (1, 20) selon vos besoins
# Créer la carte en utilisant la taille des bulles pour représenter le classement
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_sf(data = data_sf, aes(size = size), color = "black", alpha = 0.5) +
guides(size = FALSE)  # Supprimer la légende de la taille des bulles
# Redimensionner les valeurs pour les utiliser comme taille des bulles
data_sf$size <- data_sf$normalized_rank * 10  # Vous pouvez ajuster la constante (ici 10) selon vos besoins
# Créer la carte en utilisant la taille des bulles pour représenter le classement
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_sf(data = data_sf, aes(size = size), color = "black", alpha = 0.5) +
guides(size = FALSE)  # Supprimer la légende de la taille des bulles
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_centroids$normalized_rank <- 1 / data$daily_rank
# Convertir le dataframe en un objet 'sf'
data_sf <- st_as_sf(top_chanson_pays_iso_idh_pays, wkt = "geometry")
# Calculer les centroïdes des polygones (centres des pays)
data_centroids <- st_centroid(data_sf)
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_centroids$normalized_rank <- 1 / data$daily_rank
# Convertir le champ 'geometry' en un objet 'sf'
data_sf <- st_as_sf(top_chanson_pays_iso_idh_pays, wkt = "geometry")
# Calculer les centroïdes des polygones (centres des pays)
data_centroids <- st_centroid(data_sf)
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_centroids$normalized_rank <- 1 / data$daily_rank  # Vérifiez ici si le nom de la colonne est correct
View(data_centroids)
print(top_chanson_pays_iso_idh_pays)
#Afficher ce lien cartographiquement
#write.csv(top_chanson_pays_iso_idh_pays, file = "C:/Users/hasdi/OneDrive/Desktop/Projet Proba Stat/top_chanson_pays_iso_idh_pays.csv", row.names = FALSE)
my_data <- top_chanson_pays_iso_idh_pays
# Convertir le champ 'geometry' en un objet 'sf'
data_sf <- st_as_sf(my_data, wkt = "geometry")
# Calculer les centroïdes des polygones (centres des pays)
data_centroids <- st_centroid(data_sf)
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_centroids$normalized_rank <- 1 / my_data$daily_rank
# Redimensionner les valeurs pour les utiliser comme taille des bulles
data_centroids$size <- data_centroids$normalized_rank * 10  # Ajustez la constante selon vos besoins
# Créer la carte avec les bulles positionnées sur les centroïdes
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2]), size = data_centroids$size, color = "black", alpha = 0.5) +
guides(size = FALSE)  # Supprimer la légende de la taille des bulles
# Redimensionner les valeurs pour les utiliser comme taille des bulles
data_centroids$size <- data_centroids$normalized_rank * 5  # Ajustez la constante selon vos besoins
# Créer la carte avec les bulles positionnées sur les centroïdes
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2]), size = data_centroids$size, color = "black", alpha = 0.5) +
guides(size = FALSE)  # Supprimer la légende de la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Classement", guide = "legend", range = c(1, 10)) +  # Ajustez 'range' selon la plage de taille de vos bulles
labs(size = "Taille des bulles")  # Titre de la légende
# Redimensionner les valeurs pour les utiliser comme taille des bulles
data_centroids$size <- data_centroids$normalized_rank * 3
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Classement", guide = "legend", range = c(1, 10)) +  # Ajustez 'range' selon la plage de taille de vos bulles
labs(size = "Taille des bulles")  # Titre de la légende
# Redimensionner les valeurs pour les utiliser comme taille des bulles
data_centroids$size <- data_centroids$normalized_rank * 10
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Classement", guide = "legend", range = c(1, 10)) +  # Ajustez 'range' selon la plage de taille de vos bulles
labs(size = "Taille des bulles")  # Titre de la légende
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_centroids$normalized_rank <- 1 / my_data$daily_rank
# Redimensionner les valeurs pour les utiliser comme taille des bulles
data_centroids$size <- data_centroids$normalized_rank * 5
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Classement", guide = "legend", range = c(1, 10)) +  # Ajustez 'range' selon la plage de taille de vos bulles
labs(size = "Taille des bulles")  # Titre de la légende
data_centroids$daily_rank
# Transformez les classements en utilisant le logarithme
data_centroids$log_rank <- log(data_centroids$normalized_rank + 1)  # Ajout de 1 pour éviter le logarithme de 0
# Calculer les centroïdes des polygones (centres des pays)
data_centroids <- st_centroid(data_sf)
# Transformez les classements en utilisant le logarithme
data_centroids$log_rank <- log(data_centroids$normalized_rank + 1)  # Ajout de 1 pour éviter le logarithme de 0
# Calculer les centroïdes des polygones (centres des pays)
data_centroids <- st_centroid(data_sf)
# Transformez les classements en utilisant le logarithme
data_centroids$log_rank <- log(data_centroids$normalized_rank + 1)  # Ajout de 1 pour éviter le logarithme de 0
# Calculer les centroïdes des polygones (centres des pays)
data_centroids <- st_centroid(data_sf)
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_centroids$normalized_rank <- 1 / my_data$daily_rank
# Transformez les classements en utilisant le logarithme
data_centroids$log_rank <- log(data_centroids$normalized_rank + 1)  # Ajout de 1 pour éviter le logarithme de 0
# Utilisez les résultats transformés comme taille des bulles
data_centroids$size <- data_centroids$log_rank * 2  # Ajustez la constante selon vos besoins
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Classement", guide = "legend") +
labs(size = "Taille des bulles")
# Utilisez les résultats transformés comme taille des bulles
data_centroids$size <- data_centroids$log_rank * 4  # Ajustez la constante selon vos besoins
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Classement", guide = "legend") +
labs(size = "Taille des bulles")
# Utilisez les résultats transformés comme taille des bulles
data_centroids$size <- data_centroids$log_rank * 5  # Ajustez la constante selon vos besoins
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Classement de la chanson par pays", caption = "Source: Votre source de données") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Classement", guide = "legend") +
labs(size = "Taille des bulles")
# Utilisez les résultats transformés comme taille des bulles
data_centroids$size <- data_centroids$log_rank * 5  # Ajustez la constante selon vos besoins
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Données Spotify") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Populrité", guide = "legend") +
labs(size = "Taille des bulles")
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Données Spotify & IDH du UNDP") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = Longitude, y = Latitude, size = size), color = "black", alpha = 0.5) +
scale_size(name = "Populrité", guide = "legend") +
labs(size = "Taille des bulles")
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Données Spotify & IDH du UNDP") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Populrité", guide = "legend") +
labs(size = "Taille des bulles")
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Données Spotify & IDH du UNDP") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = "Longitude", y = "Latitude", size = size), color = "black", alpha = 0.5) +
scale_size(name = "Populrité", guide = "legend") +
labs(size = "Taille des bulles")
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Données Spotify & IDH du UNDP") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Populrité", guide = "legend") +
labs(size = "Taille des bulles")
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Données Spotify & IDH du UNDP") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Populrité", guide = "legend") +
labs(size = "Taille des bulles", x="Longitude", y="Latitude")
##################Influence de la géolocalisation sur la popularité#####################
#Selectionner la top chanson mondiale
top_chanson_mondiale <- subset(spotifydb, daily_rank == "1" & country =="" )
View(top_chanson_mondiale)
##################Influence de la géolocalisation sur la popularité#####################
#Selectionner la top chanson mondiale
top_chanson_mondiale <- subset(spotifydb, daily_rank == "1" & country =="" & snapshot_date =="2023-10-22")
#Selectionner la même top chanson mondiale pour voire sa popularité par pays
top_chanson_all <- subset(spotifydb, spotify_id == top_chanson_mondiale$spotify_id & snapshot_date == top_chanson_mondiale$snapshot_date)
#Enlever la top mondiale qui a country vide pour n'avoir que les pays où la chanson est un hit
#Resultat de la jointure entre la table spotify et la table des codes ISO
top_chanson_pays <- top_chanson_all %>% filter( country != "")
# Fusionner ces données avec ceux des codeIso
top_chanson_pays_iso <- merge(top_chanson_pays, isoCodes, by.x ="country", by.y ="alpha2", all = FALSE)
# Fusionner ces données avec les données sur l'IDH des pays
top_chanson_pays_iso_idh <- merge(top_chanson_pays_iso, hdiCountries, by.x = "noms_en_gb", by.y = "Country", all = FALSE)
# Effectuer la jointure entre le shapefile et la table des tops chansons
top_chanson_pays_iso_idh_pays <- merge(pays, top_chanson_pays_iso_idh, by.x = "iso3", by.y = "alpha3", all.x = FALSE)
# Calculer la régression linéaire
modele_top_chanson <- lm(daily_rank  ~ HDI_value, data=top_chanson_pays_iso_idh)
summary(modele_top_chanson)
# Nuage de points avec la ligne de régression
plot(top_chanson_pays_iso_idh$HDI_value, top_chanson_pays_iso_idh$daily_rank,
xlab = "IDH", ylab = "Classement chanson",
main = "Relation entre l'IDH et la popularité d'une chanson")
abline(modele_top_chanson, col = "red")  # Ajouter la ligne de régression
#Afficher ce lien cartographiquement
#write.csv(top_chanson_pays_iso_idh_pays, file = "C:/Users/hasdi/OneDrive/Desktop/Projet Proba Stat/top_chanson_pays_iso_idh_pays.csv", row.names = FALSE)
my_data <- top_chanson_pays_iso_idh_pays
# Convertir le champ 'geometry' en un objet 'sf'
data_sf <- st_as_sf(my_data, wkt = "geometry")
# Calculer les centroïdes des polygones (centres des pays)
data_centroids <- st_centroid(data_sf)
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_centroids$normalized_rank <- 1 / my_data$daily_rank
# Transformez les classements en utilisant le logarithme
data_centroids$log_rank <- log(data_centroids$normalized_rank + 1)  # Ajout de 1 pour éviter le logarithme de 0
# Utilisez les résultats transformés comme taille des bulles
data_centroids$size <- data_centroids$log_rank * 5  # Ajustez la constante selon vos besoins
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Données Spotify & IDH du UNDP") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Populrité", guide = "legend") +
labs(size = "Taille des bulles", x="Longitude", y="Latitude")
##################Influence de la géolocalisation sur la popularité#####################
#Selectionner la top chanson mondiale
top_chanson_mondiale <- subset(spotifydb, daily_rank == "1" & country =="" & snapshot_date =="2023-10-18")
#Selectionner la même top chanson mondiale pour voire sa popularité par pays
top_chanson_all <- subset(spotifydb, spotify_id == top_chanson_mondiale$spotify_id & snapshot_date == top_chanson_mondiale$snapshot_date)
#Enlever la top mondiale qui a country vide pour n'avoir que les pays où la chanson est un hit
#Resultat de la jointure entre la table spotify et la table des codes ISO
top_chanson_pays <- top_chanson_all %>% filter( country != "")
# Fusionner ces données avec ceux des codeIso
top_chanson_pays_iso <- merge(top_chanson_pays, isoCodes, by.x ="country", by.y ="alpha2", all = FALSE)
# Fusionner ces données avec les données sur l'IDH des pays
top_chanson_pays_iso_idh <- merge(top_chanson_pays_iso, hdiCountries, by.x = "noms_en_gb", by.y = "Country", all = FALSE)
# Effectuer la jointure entre le shapefile et la table des tops chansons
top_chanson_pays_iso_idh_pays <- merge(pays, top_chanson_pays_iso_idh, by.x = "iso3", by.y = "alpha3", all.x = FALSE)
# Calculer la régression linéaire
modele_top_chanson <- lm(daily_rank  ~ HDI_value, data=top_chanson_pays_iso_idh)
summary(modele_top_chanson)
# Nuage de points avec la ligne de régression
plot(top_chanson_pays_iso_idh$HDI_value, top_chanson_pays_iso_idh$daily_rank,
xlab = "IDH", ylab = "Classement chanson",
main = "Relation entre l'IDH et la popularité d'une chanson")
abline(modele_top_chanson, col = "red")  # Ajouter la ligne de régression
#Afficher ce lien cartographiquement
#write.csv(top_chanson_pays_iso_idh_pays, file = "C:/Users/hasdi/OneDrive/Desktop/Projet Proba Stat/top_chanson_pays_iso_idh_pays.csv", row.names = FALSE)
my_data <- top_chanson_pays_iso_idh_pays
# Convertir le champ 'geometry' en un objet 'sf'
data_sf <- st_as_sf(my_data, wkt = "geometry")
# Calculer les centroïdes des polygones (centres des pays)
data_centroids <- st_centroid(data_sf)
# Inverser le classement pour une meilleure représentation (les meilleurs classements auront de plus grandes tailles)
data_centroids$normalized_rank <- 1 / my_data$daily_rank
# Transformez les classements en utilisant le logarithme
data_centroids$log_rank <- log(data_centroids$normalized_rank + 1)  # Ajout de 1 pour éviter le logarithme de 0
# Utilisez les résultats transformés comme taille des bulles
data_centroids$size <- data_centroids$log_rank * 5  # Ajustez la constante selon vos besoins
# Créer la carte avec les bulles positionnées sur les centroïdes et une échelle logarithmique pour la taille des bulles
ggplot() +
geom_sf(data = data_sf, aes(fill = HDI_value), color = "white") +
scale_fill_gradient(low = "red", high = "green", name = "IDH") +
labs(title = "Popularité de la chanson par pays", caption = "Source: Données Spotify & IDH du UNDP") +
theme_minimal() +
geom_point(data = data_centroids, aes(x = st_coordinates(data_centroids)[, 1], y = st_coordinates(data_centroids)[, 2], size = size), color = "black", alpha = 0.5) +
scale_size(name = "Populrité", guide = "legend") +
labs(size = "Taille des bulles", x="Longitude", y="Latitude")
#Calculer la moyenne des tempo par pays
data_spotify_summary <- spotifydb %>%
group_by(country) %>%
summarise(
moyenne_tempo = mean(tempo, na.rm = TRUE),
median_tempo  = median(tempo, na.rm = TRUE),
moyenne_danceability = mean(danceability, na.rm = TRUE),
median_danceability  = median(danceability, na.rm = TRUE)
)
# Fusionner les données de spotify et codeIso
spotifyIso <- merge(data_spotify_summary, isoCodes, by.x ="country", by.y ="alpha2", all = TRUE)
#Resultat de la jointure entre la table spotify et la table des codes ISO
data_spotify_Iso <- spotifyIso %>% filter(!is.na(moyenne_tempo) & moyenne_tempo != "")
# Fusionner les données de spotify join à code ISO et les données sur l'IDH des pays
spotifyIsoHDI <- merge(data_spotify_Iso, hdiCountries, by.x = "noms_en_gb", by.y = "Country", all = TRUE)
#Resultat de la jointure entre la table data_spotify_Iso et la table des HDI par pays
data_spotify_Iso_HDI <- spotifyIsoHDI %>% filter(!is.na(moyenne_tempo) & moyenne_tempo != "")
# Enlever les enregistrements n'ayant pas de country et idh
filtered_data <- data_spotify_Iso_HDI %>% filter(!is.na(HDI_value) | !HDI_value == "")
pays <- st_read("data/world-administrative-boundaries/world-administrative-boundaries.shp")
# Effectuer la jointure entre le shapefile et la table des tops chansons
songs_pays <- merge(pays, filtered_data, by.x = "iso3", by.y = "alpha3", all.x = TRUE)
#C'est le jeu de données qui nous intéresse avec les 72 pays leur idh, le tempo moyen par pays et sa géométrie
songs_pays_spotify <- songs_pays %>%
filter(!is.na(moyenne_tempo))
# Créer une palette de couleurs pour l'IDH
palette_couleurs <- colorNumeric(palette = "Blues", domain = songs_pays_spotify$HDI_value)
# Convertir votre dataframe en objet sf
songs_pays_spotify_sf <- st_as_sf(songs_pays_spotify)
# Obtenir les centroïdes des ppays
centroids <- st_centroid(songs_pays_spotify_sf)
# Extraire les coordonnées des centroïdes
centroid_coords <- st_coordinates(centroids)
# Créer la carte Leaflet avec les centroïdes pour positionner les bulles
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = songs_pays_spotify,
fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~noms_en_gb,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", noms_en_gb, "<br>IDH: ", HDI_value,  "<br>Tempo moyen: ", moyenne_tempo,  "<br>Tempo median: ", median_tempo )
) %>%
addCircles(data = as.data.frame(centroid_coords), # Utiliser les centroïdes comme données pour les bulles
lat = ~Y,  # Latitude du centroïde
lng = ~X,  # Longitude du centroïde
radius = ~songs_pays_spotify$moyenne_danceability * 500,
color = "brown",
fillOpacity = 0.7,
popup = ~paste("Pays: ", songs_pays_spotify$noms_en_gb, "<br>Danceability: ", songs_pays_spotify$moyenne_danceability)
)
# Afficher la carte
carte
# Calculer la régression linéaire
modele <- lm(moyenne_danceability  ~ HDI_value, data=songs_pays_spotify)
summary(modele)
# Nuage de points avec la ligne de régression
plot(songs_pays_spotify$HDI_value, songs_pays_spotify$moyenne_danceability,
xlab = "IDH", ylab = "Danceability",
main = "Relation entre l'IDH et la Danceabilité d'une chanson")
abline(modele, col = "red")  # Ajouter la ligne de régression
# Créer la carte Leaflet avec les centroïdes pour positionner les bulles
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = songs_pays_spotify,
fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~noms_en_gb,
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", noms_en_gb, "<br>IDH: ", HDI_value,  "<br>Tempo moyen: ", moyenne_tempo,  "<br>Tempo median: ", median_tempo )
) %>%
addCircles(data = as.data.frame(centroid_coords), # Utiliser les centroïdes comme données pour les bulles
lat = ~Y,  # Latitude du centroïde
lng = ~X,  # Longitude du centroïde
radius = ~songs_pays_spotify$moyenne_danceability * 500,
color = "brown",
fillOpacity = 0.7,
popup = ~paste("Pays: ", songs_pays_spotify$noms_en_gb, "<br>Danceability: ", songs_pays_spotify$moyenne_danceability)
)
# Afficher la carte
carte
