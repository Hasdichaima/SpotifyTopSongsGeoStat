#Q3: Entraîner un modèle de forêt aléatoires sur le jeu train pour apprendre à prédire la variable ischateau. On prendra un modèle composé de 500 arbres.
model = randomForest(ischateau ~ ., data = train , ntree=500 , do.trace = 50)
yhat = predict(model, newdata = test)
y = test$ischateau
T = table(y, yhat)
TP = T[2,2]
TN = T[1,1]
FP = T[1,2]
FN = T[2,1]
P  = TP + FN
N  = TN + FP
Phat = TP + FP
Nhat = TN + FN
#Calcul des indicateurs:
STV = TP/P    # P(yhat=1   | Y=1)  STV, rappel
SPC = TN/N    # P(yhat=0   | Y=0)  SPC, 1-FPR
PPV = TP/Phat # P(y=1   | Yhat=1)  PPV, precision
NPV = TN/Nhat # P(y=0   | Yhat=0)  NPV
F1  = 2/(1/STV+1/PPV)  # Moyenne harmonique de STV et PPV
#Q4: la courbe ROQ
roc = function(labels, scores){
labels = labels[order(scores, decreasing=TRUE)]
return(data.frame(TPR=cumsum(labels)/sum(labels), FPR=cumsum(!labels)/sum(!labels), labels))
}
labels = as.numeric(test$ischateau)-1
scores = predict(model, newdata = test, type="prob")[,2]
ROC=roc(labels,scores)
plot(ROC$FPR,ROC$TPR,col="red",type='l')
1/sqrt(length(which(test$ischateau == 0)))
#Q5: calculer l'air de la courbe AUC
auc = function(roc_curve){
x = roc_curve$FPR
y = roc_curve$TPR
N = length(x)
dx = x[2:N]-x[1:(N-1)]
my = (y[2:N]+y[1:(N-1)])/2
return (sum(my*dx))
}
AUC <- auc(ROC)
AUC
#résultat: 0.9425888
#Q6: bootstrap
AUC_b = c(0)
for(i in 1:30){
test_b = test[sample(1:nrow(test), nrow(test), replace=TRUE), ]
labels = as.numeric(test$ischateau)-1
scores = predict(model, newdata = test, type="prob")[,2]
ROC_b  = roc(labels,scores)
lines(ROC_b$FPR,ROC_b$TPR,col="blue",type='l')
AUC_b  = c(AUC_b, auc(ROC_b))
}
plot(ROC$FPR,ROC$TPR,col="red",type='l')
#plot(density(AUC_b))
install.packages("bnlearn")
install.packages("bnlearn")
#install.packages("bnlearn")
install.packages("BiocManager")
BiocManager::install("Rgraphviz")
library("bnlearn")
install.packages("bnlearn")
library("bnlearn")
library("Rgraphviz")
#install.packages("bnlearn")
#install.packages("BiocManager")
#BiocManager::install("Rgraphviz")
library("bnlearn")
library("Rgraphviz")
#Q1: echauffement
sensibilite <- 0.75
faux_positif <- 0.005
taux_malade <- 0.08
# Probabilité d'être malade sachant que le test est positif (théorème de Bayes)
positif_malade <- sensibilite * taux_malade
positif_non_malade <- faux_positif * (1 - taux_malade)
probabilite_positif <- positif_malade + positif_non_malade
probabilite_malade_positif <- (sensibilite * taux_malade) / probabilite_positif
cat("La probabilité que le patient soit réellement malade sachant que son test est positif est :", probabilite_malade_positif, "\n")
#Q2:
G = model2network("[A][B|A]")
plot(G)
modA = c("SAIN", "MALADE"); modB = c("NEG", "POS")
pA = matrix(c(0.92, 0.08), ncol = 2, dimnames = list(NULL, modA))
pB = matrix(c(0.995, 0.005, 0.25, 0.75), ncol = 2, dimnames = list("B" = modB, "A" = modA))
model = custom.fit(G, dist = list(A = pA, B = pB))
graphviz.plot(model, layout = "dot")
model
#Q3:
yhat = cpquery(model, event, evidence, n)
#Q3:
yhat = cpquery(model, A == "MALADE", B == "POS", n=1e6)
yhat
modA = c("SAIN", "MALADE"); modB = c("NEG", "POS")
pA = matrix(c(0.92, 0.3), ncol = 2, dimnames = list(NULL, modA))
pB = matrix(c(0.995, 0.005, 0.25, 0.75), ncol = 2, dimnames = list("B" = modB, "A" = modA))
model = custom.fit(G, dist = list(A = pA, B = pB))
modA = c("SAIN", "MALADE"); modB = c("NEG", "POS")
pA = matrix(c(0.7, 0.3), ncol = 2, dimnames = list(NULL, modA))
pB = matrix(c(0.995, 0.005, 0.25, 0.75), ncol = 2, dimnames = list("B" = modB, "A" = modA))
model = custom.fit(G, dist = list(A = pA, B = pB))
graphviz.plot(model, layout = "dot")
#Q3:
yhat = cpquery(model, A == "MALADE", B == "POS", n=1e6)
yhat
setwd("E:/ING3/Projet Proba Stat")
library(dplyr)
library(ade4)
library(ggplot2)
library(factoextra)
library(spdep)
library(GGally)
library(sf)
data <- read.csv('Cleaned Data/spotify_ISO_IDH.csv', sep = ',')
str(data)
# Remplacer les virgules par des points décimaux et convertir en numérique
data$HDI_value <- as.numeric(gsub(",", ".", data$HDI_value))
##########################Analyse spatiale########################
# Charger le shapefile des pays
pays <- st_read("E:/ING3/Projet Proba Stat/world-administrative-boundaries/world-administrative-boundaries.shp")
data_spotify <- data %>%
filter(!is.na(noms_en_gb))
data_spotify_summary <- data_spotify %>%
group_by(alpha3) %>%
summarise(
moyenne_tempo = mean(tempo, na.rm = TRUE)
)
View(data_spotify_summary)
# Effectuer la jointure entre le shapefile et la table des tops chansons
songs_pays <- merge(pays, data_spotify_summary, by.x = "iso3", by.y = "alpha3", all.x = TRUE)
View(songs_pays)
songs_pays_spotify <- songs_pays %>%
filter(!is.na(moyenne_tempo))
# Créer une carte en utilisant ggplot2
ggplot() +
geom_sf(data = songs_pays_spotify, aes(fill = moyenne_tempo)) +
labs(title = "Carte du tempo moyen par pays", fill = "Moyenne du Tempo") +
theme_minimal()
View(songs_pays_spotify)
songs_pays_spotify
songs_pays_spotify$geometry
songs_pays_spotify$geometry[1]
# Convertir le DataFrame en objet sf pour être utilisé avec ggplot
sf_df <- st_as_sf(songs_pays_spotify, wkt = "geometry")
# Créer une carte en utilisant ggplot2
ggplot() +
geom_sf(data = sf_df, aes(fill = moyenne_tempo)) +
labs(title = "Carte du tempo moyen par pays", fill = "Moyenne du Tempo") +
theme_minimal()
#echantillon de données
pays_selectionnes <- songs_pays_spotify %>%
filter(country %in% c("FR", "US"))
#echantillon de données
pays_selectionnes <- songs_pays_spotify %>%
filter(iso3 %in% c("FRA", "ESP"))
View(pays_selectionnes)
# Créer une carte en utilisant ggplot2
ggplot() +
geom_sf(data = pays_selectionnes, aes(fill = moyenne_tempo)) +
labs(title = "Carte du tempo moyen par pays", fill = "Moyenne du Tempo") +
theme_minimal()
plot(st_geometry(pays_selectionnes))
ggplot(pays_selectionnes) +
geom_sf(aes(fill = color)) +
geom_sf_label(aes(label = NAME))
st_crs(pays_selectionnes)
# install.packages("ade4")
# install.packages("factoextra")
# install.packages("dplyr")
# install.packages("ggplot2")
# install.packages("spdep")
# install.packages("GGally")
install.packages("leaflet")
leaflet() %>% addTiles()
library(leaflet)
leaflet() %>% addTiles()
leaflet(data = pays_selectionnes) %>% addTiles() %>%
addMarkers(~long, ~lat, popup = ~as.character(mag))
# Créer une carte avec leaflet
ma_carte <- leaflet() %>%
addTiles() %>%  # Ajouter des tuiles (fond de carte)
addPolygons(data = pays_selectionnes, fillColor = ~moyenne_tempo) %>%  # Ajouter les polygones avec couleur basée sur le tempo
addLegend("bottomright", pal = colorNumeric("YlOrRd", domain = pays_selectionnes$moyenne_tempo), values = ~moyenne_tempo, title = "Tempo moyen")
# Créer une carte avec leaflet
ma_carte <- leaflet() %>%
addTiles() %>%  # Ajouter des tuiles (fond de carte)
addPolygons(data = pays_selectionnes, fillColor = ~moyenne_tempo) %>%  # Ajouter les polygones avec couleur basée sur le tempo
addLegend("bottomright", pal = colorNumeric("YlOrRd", domain = pays_selectionnes$moyenne_tempo), values = ~moyenne_tempo, title = "Tempo moyen")
write.csv(pays_selectionnes, file = "pays_test.csv", row.names = FALSE)
write.csv(pays_selectionnes, file = "pays_test.csv", row.names = FALSE,sep = ";")
# Convertir votre DataFrame en un objet spatial sf
votre_dataframe_sf <- st_as_sf(pays_selectionnes)
# Créer une carte avec leaflet
ma_carte <- leaflet() %>%
addTiles() %>%
addPolygons(data = votre_dataframe_sf, fillColor = "red", fillOpacity = 0.5, stroke = FALSE)
ma_carte <- leaflet() %>%
addTiles() %>%
addPolygons(data = votre_dataframe_sf, fillColor = "red", fillOpacity = 0.5, stroke = TRUE)
# Convertir votre DataFrame en un objet spatial sf
spotify_songs_sf <- st_as_sf(songs_pays)
# Créer une carte avec leaflet
ma_carte <- leaflet() %>%
addTiles() %>%
addPolygons(data = spotify_songs_sf, fillColor = "red", fillOpacity = 0.5, stroke = TRUE)
# Créer une carte avec leaflet
ma_carte <- leaflet() %>%
addTiles() %>%  # Ajouter des tuiles (fond de carte)
addPolygons(data = songs_pays_spotify, fillColor = ~moyenne_tempo) %>%  # Ajouter les polygones avec couleur basée sur le tempo
addLegend("bottomright", pal = colorNumeric("YlOrRd", domain = pays_selectionnes$moyenne_tempo), values = ~moyenne_tempo, title = "Tempo moyen")
plot(st_geometry(songs_pays_spotify))
setwd("E:/ING3/Projet Proba Stat")
library(sf)
library(dplyr)
library(sf)
# Charger le shapefile des pays
pays <- st_read("E:/ING3/Projet Proba Stat/world-administrative-boundaries/world-administrative-boundaries.shp")
setwd("E:/ING3/Projet Proba Stat")
# Charger le shapefile des pays
pays <- st_read("/world-administrative-boundaries/world-administrative-boundaries.shp")
# Charger le shapefile des pays
pays <- st_read("E:/ING3/Projet Proba Stat/world-administrative-boundaries/world-administrative-boundaries.shp")
install.packages("sf")
install.packages("sf")
# Charger le shapefile des pays
pays <- st_read("E:/ING3/Projet Proba Stat/world-administrative-boundaries/world-administrative-boundaries.shp")
library(sf)
# Charger le shapefile des pays
pays <- st_read("E:/ING3/Projet Proba Stat/world-administrative-boundaries/world-administrative-boundaries.shp")
data <- read.csv('Cleaned Data/spotify_ISO_IDH.csv', sep = ',')
str(data)
# Remplacer les virgules par des points décimaux et convertir en numérique
data$HDI_value <- as.numeric(gsub(",", ".", data$HDI_value))
# Exemple de chargement du dataframe (à adapter à vos données)
df_chansons <- data
# Joindre la géométrie des pays avec le dataframe
merged_data <- inner_join(pays, df_chansons, by = c("iso3" = "alpha3"))
library(dplyr)
# Joindre la géométrie des pays avec le dataframe
merged_data <- inner_join(pays, df_chansons, by = c("iso3" = "alpha3"))
View(merged_data)
# Calculer les moyennes des caractéristiques numériques par pays
merged_data <- merged_data %>%
group_by(country) %>%
mutate(Moyenne_tempo = mean(tempo))
# Sélectionner les colonnes pertinentes
result <- merged_data %>%
select(country, HDI_value, Moyenne_tempo, geometry)
# Afficher le résultat ou enregistrer dans un nouveau fichier si nécessaire
print(result)
library(leaflet)
# Créer une palette de couleurs pour l'IDH
palette_couleurs <- colorNumeric(palette = "viridis", domain = merged_data$HDI_value)
# Créer la carte Leaflet
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>% # Style de la carte
addPolygons(data = merged_data,
fillColor = ~palette_couleurs(IDH),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~NOM_DU_PAYS, # Étiquette des pays
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", NOM_DU_PAYS, "<br>IDH: ", IDH)
)
# Créer la carte Leaflet
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>% # Style de la carte
addPolygons(data = merged_data,
fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~country, # Étiquette des pays
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", country, "<br>IDH: ", HDI_value)
)
# Afficher la carte
carte
View(songs_pays_spotify)
setwd("C:/Users/user/Documents/GitHub/SpotifyTopSongsGeoStat")
library(ggplot2)
library(dplyr)
# Charger les données sur l'indice de développement humain des pays et table des codes iso des pays
isoCodes <- read.csv('/data/codeISOpays.csv', sep=';')
# Charger les données sur l'indice de développement humain des pays et table des codes iso des pays
isoCodes <- read.csv('data/codeISOpays.csv', sep=';')
hdiCountries <- read.csv('data/HDI_data/HDR21-22_Statistical_Annex_HDI.csv', sep=';')
spotifydb <- read.csv('data/universal_top_spotify_songs/universal_top_spotify_songs_Oct_18_28.csv')
# Fusionner les données de spotify et codeIso
spotifyIso <- merge(spotifydb, isoCodes, by.x ="country", by.y ="alpha2", all = TRUE)
isoCodes <- read.csv('data/codeISOpays.csv', sep=';')
hdiCountries <- read.csv('data/HDI_data/HDR21-22_Statistical_Annex_HDI.csv', sep=';')
spotifydb <- read.csv('data/universal_top_spotify_songs/universal_top_spotify_songs_Oct_18_28.csv')
# Fusionner les données de spotify et codeIso
spotifyIso <- merge(spotifydb, isoCodes, by.x ="country", by.y ="alpha2", all = TRUE)
#Resultat de la jointure entre la table spotify et la table des codes ISO
data_spotify_Iso <- spotifyIso %>% filter(!is.na(spotify_id) & spotify_id != "")
# Fusionner les données de spotify join à code ISO et les données sur l'IDH des pays
spotifyIsoHDI <- merge(data_spotify_Iso, hdiCountries, by.x = "noms_en_gb", by.y = "Country", all = TRUE)
#Resultat de la jointure entre la table data_spotify_Iso et la table des HDI par pays
data_spotify_Iso_HDI <- spotifyIsoHDI %>% filter(!is.na(spotify_id) & spotify_id != "")
# Sauvegarder le dataframe en tant que fichier CSV
write.csv(data_spotify_Iso_HDI, file = "spotify_ISO_IDH_Oct.csv", row.names = FALSE)
View(data_spotify_Iso_HDI)
# Filtrer les enregistrements ayant une valeur nulle
filtered_data <- data_spotify_Iso_HDI %>% filter(is.na(HDI_value) | HDI_value == "")
# Regrouper les données filtrées par noms_en_gb et compter les occurrences
grouped_data <- filtered_data %>%
group_by(noms_en_gb) %>%
summarise(count = n())
View(grouped_data)
View(filtered_data)
# Filtrer les enregistrements ayant une valeur nulle
filtered_data <- data_spotify_Iso_HDI %>% filter(!is.na(HDI_value) | !HDI_value == "")
View(filtered_data)
View(filtered_data)
#Calculer la moyenne des tempo par pays
data_spotify_summary <- filtered_data %>%
group_by(alpha3) %>%
summarise(
moyenne_tempo = mean(tempo, na.rm = TRUE)
)
View(data_spotify_summary)
#Calculer la moyenne des tempo par pays
data_spotify_summary <- filtered_data %>%
group_by(alpha3) %>%
summarise(
moyenne_tempo = mean(tempo, na.rm = TRUE),
HDI_value = HDI_value
)
#Calculer la moyenne des tempo par pays
data_spotify_summary <- filtered_data %>%
group_by(noms_en_gb) %>%
summarise(
moyenne_tempo = mean(tempo, na.rm = TRUE)
)
View(data_spotify_summary)
spotifyIsoHDI_pays <- merge(data_spotify_summary, hdiCountries, by.x = "noms_en_gb", by.y = "Country", all = TRUE)
View(spotifyIsoHDI_pays)
spotifyIsoHDI_pays <- merge(data_spotify_summary, hdiCountries, by.x = "noms_en_gb", by.y = "Country")
View(data_spotify_Iso_HDI)
isoCodes <- read.csv('data/codeISOpays.csv', sep=';')
hdiCountries <- read.csv('data/HDI_data/HDR21-22_Statistical_Annex_HDI.csv', sep=';')
spotifydb <- read.csv('data/universal_top_spotify_songs/universal_top_spotify_songs_Oct_18_28.csv')
data_spotify_summary <- spotifydb %>%
group_by(noms_en_gb) %>%
summarise(
moyenne_tempo = mean(tempo, na.rm = TRUE)
)
data_spotify_summary <- spotifydb %>%
group_by(country) %>%
summarise(
moyenne_tempo = mean(tempo, na.rm = TRUE)
)
View(data_spotify_summary)
# Fusionner les données de spotify et codeIso
spotifyIso <- merge(data_spotify_summary, isoCodes, by.x ="country", by.y ="alpha2", all = TRUE)
View(spotifyIso)
#Resultat de la jointure entre la table spotify et la table des codes ISO
data_spotify_Iso <- spotifyIso %>% filter(!is.na(moyenne_tempo) & moyenne_tempo != "")
# Fusionner les données de spotify join à code ISO et les données sur l'IDH des pays
spotifyIsoHDI <- merge(data_spotify_Iso, hdiCountries, by.x = "noms_en_gb", by.y = "Country", all = TRUE)
View(spotifyIsoHDI)
#Resultat de la jointure entre la table data_spotify_Iso et la table des HDI par pays
data_spotify_Iso_HDI <- spotifyIsoHDI %>% filter(!is.na(moyenne_tempo) & moyenne_tempo != "")
View(data_spotify_Iso_HDI)
# Sauvegarder le dataframe en tant que fichier CSV
write.csv(data_spotify_Iso_HDI, file = "spotify_ISO_IDH_Oct_carto.csv", row.names = FALSE)
# Enlever les enregistrements n'ayant pas de country et idh
filtered_data <- data_spotify_Iso_HDI %>% filter(!is.na(HDI_value) | !HDI_value == "")
View(filtered_data)
# Fusionner les données de spotify et codeIso
spotifyIso <- merge(data_spotify_summary, isoCodes, by.x ="country", by.y ="alpha2", all = TRUE)
View(spotifyIso)
pays <- st_read("data/world-administrative-boundaries/world-administrative-boundaries.shp")
# Effectuer la jointure entre le shapefile et la table des tops chansons
songs_pays <- merge(pays, filtered_data, by.x = "iso3", by.y = "alpha3", all.x = TRUE)
View(songs_pays)
songs_pays_spotify <- songs_pays %>%
filter(!is.na(moyenne_tempo))
View(songs_pays_spotify)
#library(ggmap)
library(leaflet)
# Créer une palette de couleurs pour l'IDH
palette_couleurs <- colorNumeric(palette = "viridis", domain = songs_pays_spotify$HDI_value)
# Créer la carte Leaflet
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>% # Style de la carte
addPolygons(data = songs_pays_spotify,
fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~country, # Étiquette des pays
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", country, "<br>IDH: ", HDI_value)
)
# Afficher la carte
carte
# Créer la carte Leaflet
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>% # Style de la carte
addPolygons(data = songs_pays_spotify,
fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~country, # Étiquette des pays
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", noms_en_gb, "<br>IDH: ", HDI_value)
)
# Afficher la carte
carte
# Créer la carte Leaflet
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>% # Style de la carte
addPolygons(data = songs_pays_spotify,
fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~noms_en_gb, # Étiquette des pays
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", noms_en_gb, "<br>IDH: ", HDI_value)
)
# Afficher la carte
carte
#Calculer la moyenne des tempo par pays
data_spotify_summary <- spotifydb %>%
group_by(country) %>%
summarise(
moyenne_tempo = mean(tempo, na.rm = TRUE),
median_tempo  = median(tempo, na.rm = TRUE)
)
# Fusionner les données de spotify et codeIso
spotifyIso <- merge(data_spotify_summary, isoCodes, by.x ="country", by.y ="alpha2", all = TRUE)
#Resultat de la jointure entre la table spotify et la table des codes ISO
data_spotify_Iso <- spotifyIso %>% filter(!is.na(moyenne_tempo) & moyenne_tempo != "")
# Fusionner les données de spotify join à code ISO et les données sur l'IDH des pays
spotifyIsoHDI <- merge(data_spotify_Iso, hdiCountries, by.x = "noms_en_gb", by.y = "Country", all = TRUE)
#Resultat de la jointure entre la table data_spotify_Iso et la table des HDI par pays
data_spotify_Iso_HDI <- spotifyIsoHDI %>% filter(!is.na(moyenne_tempo) & moyenne_tempo != "")
# Enlever les enregistrements n'ayant pas de country et idh
filtered_data <- data_spotify_Iso_HDI %>% filter(!is.na(HDI_value) | !HDI_value == "")
pays <- st_read("data/world-administrative-boundaries/world-administrative-boundaries.shp")
# Effectuer la jointure entre le shapefile et la table des tops chansons
songs_pays <- merge(pays, filtered_data, by.x = "iso3", by.y = "alpha3", all.x = TRUE)
#C'est le jeu de données qui nous intéresse avec les 72 pays leur idh, le tempo moyen par pays et sa géométrie
songs_pays_spotify <- songs_pays %>%
filter(!is.na(moyenne_tempo))
# Créer une palette de couleurs pour l'IDH
palette_couleurs <- colorNumeric(palette = "viridis", domain = songs_pays_spotify$HDI_value)
# Créer la carte Leaflet
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>% # Style de la carte
addPolygons(data = songs_pays_spotify,
fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~noms_en_gb, # Étiquette des pays
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", noms_en_gb, "<br>IDH: ", HDI_value)
)
# Créer la carte Leaflet
carte <- leaflet() %>%
addProviderTiles("CartoDB.Positron") %>% # Style de la carte
addPolygons(data = songs_pays_spotify,
fillColor = ~palette_couleurs(HDI_value),
fillOpacity = 0.7,
color = "white",
stroke = TRUE,
weight = 1,
label = ~noms_en_gb, # Étiquette des pays
labelOptions = labelOptions(
style = list("font-weight" = "normal", padding = "3px 8px"),
textsize = "15px",
direction = "auto"
),
popup = ~paste("Pays: ", noms_en_gb, "<br>IDH: ", HDI_value,  "<br>Tempo moyen: ", moyenne_tempo,  "<br>Tempo median: ", median_tempo )
)
# Afficher la carte
carte
